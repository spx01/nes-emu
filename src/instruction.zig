const std = @import("std");

const Operand = union(enum) {
    implicit: void,
    acc: void,

    page0: u8,
    abs: u16,
    ind: u16,
    rel: u8,
    imm: u8,

    // addr = page0(arg + x)
    page0_x: u8,
    page0_y: u8,

    // addr = arg + x
    abs_x: u16,
    abs_y: u16,

    // addr = *page0(arg + x) | *page0(arg + x + 1) << 8
    idx_ind: u8,

    // addr = (*page0(arg) | *page0(arg + 1) << 8) + y
    ind_idx: u8,
};

const Mode = std.meta.Tag(Operand);

const Op = enum {
    adc,
    ahx,
    aldy,
    alr,
    anc,
    // I will not settle for less
    @"and",
    arr,
    asl,
    axs,
    bcc,
    bcs,
    beq,
    bit,
    bmi,
    bne,
    bpl,
    brk,
    bvc,
    bvs,
    ccpy,
    clc,
    cld,
    cli,
    clv,
    cmp,
    cpx,
    cpy,
    dcp,
    dec,
    dex,
    dey,
    ecpx,
    eor,
    inc,
    inx,
    iny,
    isc,
    jmp,
    jsr,
    las,
    lax,
    lda,
    ldx,
    ldy,
    lsr,
    nop,
    ora,
    pha,
    php,
    pla,
    plp,
    rla,
    rol,
    ror,
    rra,
    rti,
    rts,
    sax,
    sbc,
    sec,
    sed,
    sei,
    shx,
    shy,
    slo,
    sre,
    sta,
    stp,
    stx,
    sty,
    tas,
    tax,
    tay,
    tsx,
    txa,
    txs,
    tya,
    xaa,
};

const op_table = [256]Op{
    .brk,
    .ora,
    .stp,
    .slo,
    .nop,
    .ora,
    .asl,
    .slo,
    .php,
    .ora,
    .asl,
    .anc,
    .nop,
    .ora,
    .asl,
    .slo,
    .bpl,
    .ora,
    .stp,
    .slo,
    .nop,
    .ora,
    .asl,
    .slo,
    .clc,
    .ora,
    .nop,
    .slo,
    .nop,
    .ora,
    .asl,
    .slo,
    .jsr,
    .@"and",
    .stp,
    .rla,
    .bit,
    .@"and",
    .rol,
    .rla,
    .plp,
    .@"and",
    .rol,
    .anc,
    .bit,
    .@"and",
    .rol,
    .rla,
    .bmi,
    .@"and",
    .stp,
    .rla,
    .nop,
    .@"and",
    .rol,
    .rla,
    .sec,
    .@"and",
    .nop,
    .rla,
    .nop,
    .@"and",
    .rol,
    .rla,
    .rti,
    .eor,
    .stp,
    .sre,
    .nop,
    .eor,
    .lsr,
    .sre,
    .pha,
    .eor,
    .lsr,
    .alr,
    .jmp,
    .eor,
    .lsr,
    .sre,
    .bvc,
    .eor,
    .stp,
    .sre,
    .nop,
    .eor,
    .lsr,
    .sre,
    .cli,
    .eor,
    .nop,
    .sre,
    .nop,
    .eor,
    .lsr,
    .sre,
    .rts,
    .adc,
    .stp,
    .rra,
    .nop,
    .adc,
    .ror,
    .rra,
    .pla,
    .adc,
    .ror,
    .arr,
    .jmp,
    .adc,
    .ror,
    .rra,
    .bvs,
    .adc,
    .stp,
    .rra,
    .nop,
    .adc,
    .ror,
    .rra,
    .sei,
    .adc,
    .nop,
    .rra,
    .nop,
    .adc,
    .ror,
    .rra,
    .nop,
    .sta,
    .nop,
    .sax,
    .sty,
    .sta,
    .stx,
    .sax,
    .dey,
    .nop,
    .txa,
    .xaa,
    .sty,
    .sta,
    .stx,
    .sax,
    .bcc,
    .sta,
    .stp,
    .ahx,
    .sty,
    .sta,
    .stx,
    .sax,
    .tya,
    .sta,
    .txs,
    .tas,
    .shy,
    .sta,
    .shx,
    .ahx,
    .ldy,
    .lda,
    .ldx,
    .lax,
    .ldy,
    .lda,
    .ldx,
    .lax,
    .tay,
    .lda,
    .tax,
    .lax,
    .ldy,
    .lda,
    .ldx,
    .lax,
    .bcs,
    .lda,
    .stp,
    .lax,
    .ldy,
    .lda,
    .ldx,
    .lax,
    .clv,
    .lda,
    .tsx,
    .las,
    .ldy,
    .lda,
    .ldx,
    .lax,
    .cpy,
    .cmp,
    .nop,
    .dcp,
    .cpy,
    .cmp,
    .dec,
    .dcp,
    .iny,
    .cmp,
    .dex,
    .axs,
    .cpy,
    .cmp,
    .dec,
    .dcp,
    .bne,
    .cmp,
    .stp,
    .dcp,
    .nop,
    .cmp,
    .dec,
    .dcp,
    .cld,
    .cmp,
    .nop,
    .dcp,
    .nop,
    .cmp,
    .dec,
    .dcp,
    .cpx,
    .sbc,
    .nop,
    .isc,
    .cpx,
    .sbc,
    .inc,
    .isc,
    .inx,
    .sbc,
    .nop,
    .sbc,
    .cpx,
    .sbc,
    .inc,
    .isc,
    .beq,
    .sbc,
    .stp,
    .isc,
    .nop,
    .sbc,
    .inc,
    .isc,
    .sed,
    .sbc,
    .nop,
    .isc,
    .nop,
    .sbc,
    .inc,
    .isc,
};

comptime {
    // ensure sanity
    const correct_pairs = [_]struct { u8, Op }{
        .{ 0, .brk },
        .{ 0x20, .jsr },
        .{ 0x80 + 0x11, .sta },
    };
    for (correct_pairs) |pair| {
        std.debug.assert(op_table[pair[0]] == pair[1]);
    }
}

pub fn decode(opcode: u8) !Mode {
    _ = opcode;
    return .implicit;
}
